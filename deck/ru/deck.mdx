import { Image, Notes, Head } from "mdx-deck";

import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";

import {
  vsDark as naiveTheme,
  nightOwl as smartTheme
} from "@code-surfer/themes"


import myTheme from './lib/theme'
export const theme = myTheme
//export const theme = smartTheme;

import counterWithLogger from "./diagrams/counterWithLogger.svg";

import naive from "./diagrams/naive.svg";
import naive1 from "./diagrams/naive1.svg";
import naive2 from "./diagrams/naive2.svg";
import naive3 from "./diagrams/naive3.svg";
import requiredInterface from "./diagrams/requiredInterface.svg";
import requiredInterface0 from "./diagrams/requiredInterface0.svg";
import requiredInterface1 from "./diagrams/requiredInterface1.svg";
import requiredInterface2 from "./diagrams/requiredInterface2.svg";

<Head>
  <title>Принцип Инверсии Зависимостей</title>
</Head>

# Презентация презентации

<Notes>

Вначале немного о самой презентации

Что хотелось попробовать ?

- Легальную разработку и публикацию презентаций вне корпоративной среды:
  - разработка презентации исключительно на инструментах Open Source (mdx-deck, code-surfer, draw.io)
- постоянную доступность презентаций онлайн, в том числе в режиме просмотра speaker notes - заметок докладчика

...
</Notes>

---

# Новые жанры

<Notes>
...

А вообще складывается впечатление, что в последнее время понемногу формируются новые комбинированные жанры представления
информации, такие как видео + слайды, текст + видео (публикации такого формата теперь часто появляются на habr).

В данном случае делается попытка попробовать ещё один гибридный вариант информационного продукта: *презентация + текст*.

Этот вариант предполагает, что презентация должна обладать определённой степенью самодостаточности для того, чтобы её
можно было полноценно воспринимать даже при отсутствии докладчика.

Эта возможность обеспечивается тем, что презентация публикуется в виде "слайды + заметки докладчика", где заметки
докладчика представлены не короткими подсказками, как это обычно бывает, а гораздо более литературным текстом (насколько
автор мог сделать его таковым), пригодным для восприятия не только автором презентации, но и широким кругом читателей.

...
</Notes>

---

### Для подготовки использовались инструменты:

- [mdx-deck](https://github.com/jxnblk/mdx-deck)
- [code-surfer](https://github.com/pomber/code-surfer)
- [drawio](https://github.com/jgraph/drawio)

<Notes>

Кратко об используемых инструментах:
- *MDX-DECK* - среда разработки презентаций на markdown + React (сама mdx-deck реализована на React)
- *Code Surfer* - своего рода плагин для mdx-deck, позволяющий красиво демонстрировать фрагменты кода
- *Draw.io* - продукт проекта diagrams.net, позволяющий бесплатно, в том числе на desktop и в онлайн, создавать
необходимые диаграммы.

В последующих докладах (до тех пор, пока не появится что-то лучшее) для подготовки презентаций предполагается
использовать именно этот набор инструментов.

</Notes>

---

# Режим докладчика

- *Alt+P* - на Windows
- *Option+P* - на Mac

<Notes>
...
Эту презентацию можно будет повторно пересмотреть-перечитать в режиме докладчика, при котором одномоментно виден и
слайд, и сопровождающий его текст.

Режим докладчика включается комбинацией клавиш *Alt+P* - на Windows и *Option+P* - на Mac.

</Notes>

---

# Презентация-стартер

<Notes>

Слайд можно понимать в двух смыслах: и как стартер презентации, и как стартер DIP-CA-решения.

</Notes>

---

# ЕЩЁ РАЗ 

---

# О ПРИНЦИПЕ
# ИНВЕРСИИ ЗАВИСИМОСТЕЙ

<Notes>
...

Этот принцип изложен на бесчисленном числе сетевых и прочих ресурсов.

Но по достоинству до сих пор так и не оценён.

Сделаем попытку это исправить.

Какова целевая аудитория у этой презентации ?
Конечно, в первую очередь это разработчики, не знакомые или недостаточно хорошо знакомые  с принципом *Dependency
Inversion*.

Но, надеюсь, презентация будет интересна существенно большему кругу "зрителей", поскольку в ней затрагиваются и другие
интересные на взгляд автора вопросы.

Кто-то, конечно, скажет или подумает, что некоторые детали предлагаемой "разжёвываются" больше, чем нужно.
Да, для кого-то это определённо так, но и предлагаемый уровень детализации наверняка тоже кому-то может пригодиться. 

Примеры приводятся на TypeScript, но они без сомнения также будут понятны разработчикам на Java, на C#, и на прочих
языках, имеющих понятие интерфейса. 

...
</Notes>

---

# Вы узнаете

<Notes>
...

Из этой презентации вы узнаете

...
</Notes>

---

- В чём суть инверсии

---

- В чём суть инверсии
- При чём здесь Чистая Архитектура

---

- В чём суть инверсии
- При чём здесь Чистая Архитектура
- Как это выглядит на TypeScript
---

- В чём суть инверсии
- При чём здесь Чистая Архитектура
- Как это выглядит на TypeScript
- Как это выглядит на UML

---

- В чём суть инверсии
- При чём здесь Чистая Архитектура
- Как это выглядит на TypeScript
- Как это выглядит на UML
- Все ли зависимости стоит инвертировать

---

- В чём суть инверсии
- При чём здесь Чистая Архитектура
- Как это выглядит на TypeScript
- Как это выглядит на UML
- Все ли зависимости стоит инвертировать
- Как устроены плагины

---

<p style="font-size: 200px; text-align:left; font-weight:bold; padding:100px;">
S O L I D
</p>

<Notes>

Начнём с принципов SOLID.

</Notes>

---

<p style="font-size: 70px; text-align:left; padding:100px;">
    <i>"Использование принципов SOLID способствует созданию такой программной системы, которую будет легко поддерживать и расширять в течение долгого времени."</i>
    <p style="font-size: 50px; text-align:right; color:#addb67;">Из Википедии</p>
</p>

<Notes>

Почему для нас так важен именно SOLID ?

По сути принципы SOLID являются принципами *Чистой Архитектуры*.

В тех случаях, когда требуется создать долгоживущий проект с устойчивым развитием, следование этим принципам необходимо. 

При разработке корпоративного ПО такое качество, как способность к устойчивому развитию является одним из главных
приоритетов.

</Notes>

---

- **S**ingle Responsibility Principle (SRP)

- **O**pen-Closed Principle (OCP)

- **L**iskov Substitution Principle (LCP)

- **I**nterface Segregation Principle (ICP)

- **D**ependency Inversion Principle (DIP)

<Notes>
Как известно, SOLID это аббревиатура, в которой каждой букве соответствует один из пяти принципов.
</Notes>

---

- **S**ingle Responsibility Principle (SRP)

- **O**pen-Closed Principle (OCP)

- **L**iskov Substitution Principle (LCP)

- **I**nterface Segregation Principle (ICP)

- **Dependency Inversion Principle** (**DIP**)

<Notes>
Сегодня будем говорить о принципе, обозначенном буквой - 'D', но который, несмотря на своё последнее место, для Чистой
Архитектуры, пожалуй, является одним из главных.

Как говорится, "The last but not the least".

</Notes>

---
# Рассмотрим простейший счётчик,
## логирующий свои события

<Notes>

Рассмотрим простейший счётчик, которому нужно логировать каждую операцию изменения своего значения, в данном случае - 
выполняемую функцией *increment()*.

</Notes>

---

<Image src={counterWithLogger} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Пунктирная стрелка с надписью *Use* в UML означает зависимость.

Как нетрудно догадаться, благодаря надписи *Use*, стрелка направлена от зависимого модуля к модулю-зависимости.

</Notes>

---

<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step subtitle="Наивная реализация">

```ts file=../../src/naive/NaiveCounter.ts title="NaiveCounter"
```

```ts file=../../src/naive/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>
...

Посмотрим на код наивной реализации нашего счётчика.

Но в чём проявляется эта наивность ?

...
</Notes>

---
<CodeSurferColumns themes={[naiveTheme, naiveTheme]}>

<Step subtitle="Design-time-зависимость от класса ConsoleLogger">

```ts 1,5 file=../../src/naive/NaiveCounter.ts title="NaiveCounter"
```

```ts 1 file=../../src/naive/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>
...

Прежде всего она проявляется в том, что модуль бизнес-логики *NaiveCounter* имеет design-time-зависимость от модуля
*ConsoleLogger*, остальное уже вторично.

В таких случаях ещё часто говорят, что здесь присутствует зависимость от реализации.

Минусы этого решения для многих вполне очевидны, перечислять их все здесь не будем, поскольку такое перечисление уже
вышло бы за пределы предмета данной презентации. 

...
</Notes>

---

<Image src={naive} style={{ width: '100vw', height: '100vh'}}/>

---

<Image src={naive1} style={{ width: '100vw', height: '100vh'}}/>

---

<Image src={naive2} style={{ width: '100vw', height: '100vh'}}/>

---

<Image src={naive3} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Отметим, что Design-time-зависимость всегда означает и run-time-зависимость, но обратное неверно, как дальше будет
показано. 

</Notes>

---

<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step subtitle="Реализация с использованием принципа Dependency Inversion">

```ts file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

```ts file=../../src/dip/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

<Step subtitle="Присутствует только run-time-зависимость">

```ts 5:9,14,18 file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

```ts 1,3 file=../../src/dip/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

<Step subtitle="Инъекция зависимости через конструктор">

```ts 4 file=../../src/dip/index.ts title="index"
```

```ts 14 file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

</Step>

</CodeSurferColumns>

<Notes>
...

Нужно поподробнее и с картинками

...
</Notes>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Сравниваем головные модули">

```ts file=../../src/naive/index.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/index.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Сравниваем головные модули">

```ts 3 file=../../src/naive/index.ts subtitle="Наивная реализация"
```

```ts 2,4 file=../../src/dip/index.ts subtitle="С использованием DIP"
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Сравниваем бизнес-логику - сами счётчики">

```ts file=../../src/naive/NaiveCounter.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/CounterInteractor.ts subtitle="С использованием DIP"
```

</Step>

<Step title="В главном нет различий">

```ts 7:10 file=../../src/naive/NaiveCounter.ts subtitle="Наивная реализация"
```

```ts 16:19 file=../../src/dip/CounterInteractor.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Но дьявол в деталях">

```ts 1,5 file=../../src/naive/NaiveCounter.ts subtitle="Design-time зависимость счётчика от реализации логгера"
```

```ts 5:9,14 file=../../src/dip/CounterInteractor.ts subtitle="Счётчик ничего не знает о реализации логгера"
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns themes={[naiveTheme, myTheme]}>

<Step title="Сравниваем логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Наивная реализация"
```

```ts file=../../src/dip/ConsoleLogger.ts subtitle="С использованием DIP"
```

</Step>

<Step title="Сравниваем логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Логгер существует сам по себе"
```

```ts 1,3 file=../../src/dip/ConsoleLogger.ts subtitle="Design-time зависимость реализации логгера от выходного интерфейса счётчика"
```

</Step>

<Step title="Сравниваем логгеры">

```ts file=../../src/naive/ConsoleLogger.ts subtitle="Логгер существует сам по себе"
```

```ts 1,3[28:45] file=../../src/dip/ConsoleLogger.ts subtitle="Логгер реализует выходной интерфейс счётчика"
```

</Step>

</CodeSurferColumns>

<Notes>
Что такое *требуемый интерфейс*, что такое *требование интерфейса* ?
Что такое *реализуемый интерфейс*, *реализация интерфейса*, надеюсь, все хорошо знают
...
</Notes>

---

# Ну и где здесь инверсия?

---
# Что такое *требуемый интерфейс*?


<Notes>

Что такое *требуемый (required) интерфейс* ?

</Notes>

---
<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step title="Требуемый (required) интерфейс">

<Image align="middle" src="https://martinfowler.com/bliki/images/requiredInterface/requiredInterface_sketch.png" style={{ width: '40vw', height: '40vh', align: 'right' }}/>

<p style="font-size: 40px; text-align:left; padding:100px;">
    <i>
        A <b>required interface</b> is an interface that is defined by the client of an interaction that specifies what a
        supplier component needs to do so that it can be used in that interaction.
    </i>
    <p style="font-size: 50px; text-align:right; color:#addb67;">Martin Fowler</p>
</p>

</Step>

</CodeSurferColumns>

---

<Image src={requiredInterface} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Модуль, вызывающий методы интерфейса и модуль, реализующий интерфейс, для краткости назовём, соответственно,
*вызывающим* и *реализующим*.

... 
</Notes>

---

<Image src={requiredInterface1} style={{ width: '100vw', height: '100vh'}}/>

---

<Image src={requiredInterface0} style={{ width: '100vw', height: '100vh'}}/>

<Notes>

Этот слайд отвечает на вопрос, а в чём, собственно, инверсия, что именно инвертируется ?

Так вот на слайде видно, что направление Know(design-time)-зависимости инвертировано относительно
Call(run-time)-зависимости.
 
</Notes>

---

<Image src={requiredInterface2} style={{ width: '100vw', height: '100vh'}}/>

<Notes>
...

Требуемый интерфейс не обязательно должен принадлежать вызывающему, требующему реализацию интерфейса модулю. Он может
быть и внешним, например, когда он определяется каким-то стандартом.

В таких случаях говорят, что оба модуля, и вызывающий, и реализующий, зависят от одной и той же абстракции.   

И, кстати, в данном случае здесь не просматривается какой-либо "инверсии", что в частности, говорит о том, что название
принципа DIP не вполне отражает его суть.
 
</Notes>

---

<p style="font-size: 50px; text-align:left; padding:100px;">
    <i>
    One might question why I use the word “inversion”. Frankly, it is because more traditional software development
    methods, such as Structured Analysis and Design, tend to create software structures in which high level modules
    depend upon low level modules, and in which abstractions depend upon details. Indeed one of the goals of these
    methods is to define the subprogram hierarchy that describes how the high level modules make calls to the low level
    modules. ... Thus, the dependency structure of a well designed object oriented program is “inverted” with respect to
    the dependency structure that normally results from traditional procedural methods.
    </i>
    <p style="font-size: 50px; text-align:right; color:#addb67;">Robert C Martin</p>
</p>

---

<CodeSurferColumns themes={[myTheme, myTheme]}>

<Step>

```ts 5:9,14,18 file=../../src/dip/CounterInteractor.ts title="CounterInteractor"
```

```ts 1,3 file=../../src/dip/ConsoleLogger.ts title="ConsoleLogger"
```

</Step>

</CodeSurferColumns>

<Notes>
...

Вернёмся к этому коду

Здесь *CounterInteractor* играет роль *InterfaceRequirer*-а, причём требуемый интерфейс - *Logger* - определяется в теле
*CounterInteractor*-а, а значит *Инверсия Зависимости* здесь присутствует.
 
*ConsoleLogger* играет роль *InterfaceImplementer*-а - модуля, реализующего требуемый интерфейс. 

...
</Notes>


---

# Точки расширения

---

# Плагины


---

# СПАСИБО ЗА ВНИМАНИЕ!

---

# Исходники

[https://github.com/softspiders/dip-in-ca](https://github.com/softspiders/dip-in-ca)
